{"version":3,"sources":["Scripts/Tools/Constants.js","logo.svg","Scripts/Tools/Tools.js","Scripts/entities/Sentence.js","Scripts/entities/Node.js","Scripts/RevisionEngine.js","App.js","serviceWorker.js","index.js"],"names":["Constants","connectives","CONJUCTION","DISJUNCTION","NEGATION","IMPLICATION","BICONDITION","nodeTypes","FORMULA","CONNECTIVE","VARIABLE","module","exports","__webpack_require__","p","Sentence","require","Tools","beliefBase","st","console","log","length","map","b","toString","sentence","syntaxTree","name","A","includes","replace","inputString","origin","stringName","index","Node","Object","_Users_YM_Dropbox_2_semester_DTU_02180_AI_Project2_BeliefRevision_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","constructSyntaxTree","parent","epestimicOrder","children","c","sort","_ref","type","_Users_YM_Dropbox_2_semester_DTU_02180_AI_Project2_BeliefRevision_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__","calculateChildren","nodeType","getNodeType","variableValue","getValue","input","arguments","undefined","childrenStrings","currentChildString","isMakingString","isConuctionString","nameToArray","_Users_YM_Dropbox_2_semester_DTU_02180_AI_Project2_BeliefRevision_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__","forEach","push","_this","childNodes","result","parseToStrings","branches","branch","connective","str","sortedBranches","child","tools","RevisionHelper","newSentence","beliefSet","inBeliefBase","bbSentenceRoot","newSentenceRoot","consequences","sentenceToPush","s","bbDisjunctions","nsDisjunctions","isDisjunctions","node","indexOf","negation","splice","newConsequence","bbChild","i","nsChild","k","expand","updateBeliefBase","beliefeSet","_this2","getIndexByName","contract","sOne","sTwo","sOneName","sTwoName","belifeSet","maxSubSets","maxSubsets","_this3","belief","resolution","o","newSubset","toConsumableArray","ielement","error","parsedSentence","parseSentence","formatedInputSentence","sentenceChildren","some","toSortedString","stringSentence","checkConsistency","addEntailments","partiallyMeetContraction","App","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","newBeliefs","trim","split","newBelieefToAdd","newBB","setState","join","react_default","a","createElement","className","onClick","addBelief","bind","value","onChange","e","target","placeholder","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7a4c6bdd.chunk.js","sourcesContent":["const connectives = {\n  CONJUCTION: \"Λ\",\n  DISJUNCTION: \"V\",\n  NEGATION: \"¬\",\n  IMPLICATION: \"->\",\n  BICONDITION: \"<->\"\n};\nconst nodeTypes = {\n  FORMULA: \"FORMULA\",\n  CONNECTIVE: \"CONNECTIVE\", // V,Λ\n  VARIABLE: \"VARIABLE\" //p,q,¬r\n};\nconst Constants = {\n  connectives,\n  nodeTypes\n};\nmodule.exports = Constants;\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","const Sentence = require(\"../entities/Sentence\");\nclass Tools {\n  printBelifeBase(beliefBase, st) {\n    console.log(\"\\n\");\n    st && console.log(st);\n    console.log(\n      \"-Printing belife set\" + \" (\" + beliefBase.length + \" elements):\"\n    );\n    beliefBase.map(b => {\n      console.log(b.toString());\n    });\n  }\n  printSentencee(sentence, st) {\n    console.log(\"\\n\");\n    st && console.log(st);\n    console.log(\"Printing seentence:\", sentence.syntaxTree.name);\n  }\n  negation(A) {\n    //¬\n    if (A.length <= 2) {\n      return A.includes(\"¬\") ? A.replace(\"¬\", \"\") : \"¬\" + A;\n    }\n    return A;\n  }\n\n  parseSentence(inputString, origin) {\n    return new Sentence(inputString, origin);\n  }\n\n  getIndexByName(stringName, beliefBase) {\n    for (let index = 0; index < beliefBase.length; index++) {\n      const element = beliefBase[index];\n      if (stringName === element.toString()) {\n        return index;\n      }\n    }\n    return -1;\n  }\n}\nmodule.exports = new Tools();\n","const Node = require(\"./Node\");\nclass Sentence {\n  //syntaxTree\n  constructor(inputString, origin) {\n    this.syntaxTree = this.constructSyntaxTree(inputString); //\n    this.origin = origin; //Array of other sentences that the sentence is a conswquence of. Empty array if userinput is origin.\n  }\n  constructSyntaxTree(inputString) {\n    return new Node({\n      name: inputString,\n      parent: null,\n      epestimicOrder: 0\n    });\n  }\n  toString() {\n    return this.syntaxTree.name;\n  }\n  toSortedString() {\n    return this.syntaxTree.children.length === 1\n      ? this.syntaxTree.children[0].children\n          .map(c => c.name)\n          .sort()\n          .toString()\n      : this.toString();\n  }\n}\nmodule.exports = Sentence;\n","const Constants = require(\"../Tools/Constants\");\nconst nodeTypes = Constants.nodeTypes;\nclass Node {\n  // p,q,r\n  constructor({ name, parent, type, children }) {\n    this.name = name; //name of the variable //e.g. p,q,r\n    // this._id = _id; //unique id, (0,1,2,3,4..) ONLY SENTENCES HAVE IDs\n    this.parent = parent; //TODO: make nested\n    this.children = children ? children : this.calculateChildren();\n\n    try {\n      //  this.children = children ? children : this.calculateChildren();\n    } catch (error) {\n      console.log(\"error:\", error);\n\n      // helper.printBelifeBase(beliefBase);\n    }\n    this.nodeType = type ? type : this.getNodeType();\n    // console.log(\"new node\", this.nodeType);\n    this.variableValue = this.getValue();\n  }\n  getValue() {\n    if (this.nodeType === nodeTypes.VARIABLE) {\n      return !this.name.includes(\"¬\");\n    } else if (this.nodeType === nodeTypes.CONNECTIVE) {\n      return !this.name.includes(\"¬\");\n    }\n  }\n\n  parseToStrings(input, containsConjuction = false) {\n    let childrenStrings = [];\n    let currentChildString = \"\";\n    let isMakingString = false;\n    let isConuctionString = false;\n\n    let nameToArray = [];\n    nameToArray = [...input];\n\n    nameToArray.forEach((c, index) => {\n      if (!c.includes(\")\") && !c.includes(\"(\")) {\n        if (isMakingString) {\n          currentChildString += c;\n        } else if (isConuctionString && nameToArray.length > 3) {\n          //  console.log('isConuctionString',c)\n          currentChildString += c;\n        } else if (!(nameToArray[index + 1] || \"\").includes(\"Λ\")) {\n          //if next char is NOT Λ\n          //  console.log(\"43 push\", c);\n          if (c === \"Λ\") {\n            containsConjuction = true;\n          }\n          if (!c.includes(\"¬\")) {\n            childrenStrings.push(nameToArray[index - 1] === \"¬\" ? \"¬\" + c : c);\n          }\n        } else {\n          isConuctionString = true;\n          currentChildString += c;\n        }\n      } else if (c.includes(\"(\")) {\n        isMakingString = true;\n      } else if (c.includes(\")\")) {\n        isMakingString = false;\n        //     console.log('61 push',currentChildString)\n\n        childrenStrings.push(currentChildString);\n        currentChildString = \"\";\n      }\n      if (\n        isConuctionString &&\n        !(nameToArray[index + 1] || \"\").includes(\"Λ\") &&\n        !c.includes(\"Λ\") &&\n        !c.includes(\"¬\")\n      ) {\n        //   console.log(\"68 push\", currentChildString);\n        // currentChildString += c;\n\n        childrenStrings.push(currentChildString);\n        currentChildString = \"\";\n        isConuctionString = false;\n      }\n    });\n    //}\n    //    console.log(\"currentChildString\", currentChildString);\n    //console.log('containsCOnjuction',containsConjuction)\n    // return containsConjuction ? this.parseToStrings(childrenStrings,containsConjuction) : childrenStrings;\n    return childrenStrings;\n  }\n  calculateChildren() {\n    let childNodes = [];\n    let result = [];\n\n    let name = this.name;\n    // console.log(\"name\", name);\n\n    if (\n      !name.includes([\"Λ\"]) &&\n      !name.includes([\"V\"]) &&\n      (name.length === 1 || (name.length == 2 && name.includes(\"¬\")))\n    ) {\n      this.nodeType = nodeTypes.VARIABLE;\n      //  console.log(\"in variable\");\n      return [];\n    } else {\n      // \"(AVB)Λ(DVE)ΛC\"\n\n      let childrenStrings = this.parseToStrings(this.name);\n      //   console.log('childrenStrings',childrenStrings)\n      let branches = [];\n      let branch = { connective: null, children: [] };\n      childrenStrings.forEach(str => {\n        if (str === \"V\" || str === \"Λ\") {\n          if (branch.connective && branch.connective != str) {\n            branches.push(branch);\n            branch = { connective: str, children: [] };\n            // add and reset\n          } else {\n            branch.connective = str;\n          }\n        } else {\n          if (!branch.connective) {\n            branch.connective = str.includes(\"Λ\") && str.length > 1 ? \"Λ\" : \"V\";\n          }\n          branch.children.push(str);\n        }\n      });\n      if (branch.children.length > 0) {\n        branches.push(branch);\n      }\n\n      let sortedBranches = {\n        connective: branches[0].connective || \"V\",\n        children: []\n      };\n      // console.log(\"branches\", branches);\n      branches.map(b => {\n        // console.log('branch',b)\n\n        if (b.connective === \"Λ\") {\n          ///if()\n          /*  if(branches.length <=1){\n  \n      \n            let connectiveString = \"\";\n            b.children.forEach((c, index) => {\n              if (index === 0) {\n                connectiveString += \"(\" + c + \")\";\n              } else {\n                connectiveString += \"Λ(\" + c + \")\";\n              }\n            });\n            //   console.log('connectiveString',connectiveString)\n            sortedBranches.children.push(connectiveString);\n          }else{*/\n\n          sortedBranches.children.push(b);\n\n          //        }\n        } else {\n          //if V\n          sortedBranches.children.push(b);\n        }\n      });\n      //console.log(\"sortedBranches\", sortedBranches);\n\n      sortedBranches.children.forEach(child => {\n        if (child.connective) {\n          child.children.forEach(c => {\n            childNodes.push(new Node({ name: c, parent: child }));\n          });\n        } else {\n          console.log(\"in else\");\n\n          childNodes.push(new Node({ name: child.children, parent: this }));\n        }\n      });\n\n      result.push(\n        new Node({\n          name: sortedBranches.connective,\n          children: childNodes,\n          type: nodeTypes.CONNECTIVE\n        })\n      );\n    }\n    this.nodeType = nodeTypes.FORMULA;\n\n    return result;\n    //return childNodes;\n  }\n\n  getNodeType() {\n    if (this.nodeType) {\n      return this.nodeType;\n    }\n  }\n}\n\nmodule.exports = Node;\n","const tools = require(\"./Tools/Tools\");\nconst Constants = require(\"./Tools/Constants\");\nconst nodeTypes = Constants.nodeTypes;\nconst connectives = Constants.connectives;\nexport default class RevisionHelper {\n  /**\nremoves senttencee from a belifeset\n*/\n\n  addEntailments(newSentence, beliefSet) {\n    //Cn-function\n    //first we check if sentence already is in belifebase\n    if (this.inBeliefBase(newSentence, beliefSet)) {\n      console.log(\"in belief base true\");\n      return;\n    }\n    let newSentenceRoot = newSentence.syntaxTree;\n    let bbSentenceRoot;\n    let consequences = []; //string;\n\n    //add consequences\n    //SR3\n    if (\n      newSentenceRoot.children[0] &&\n      newSentenceRoot.children[0].name === connectives.CONJUCTION\n    ) {\n      newSentenceRoot.children[0].children.map(c => {\n        let sentenceToPush = [c.name, [newSentenceRoot.name]];\n\n        consequences.push(sentenceToPush);\n      });\n    }\n\n    beliefSet.forEach(s => {\n      bbSentenceRoot = s.syntaxTree;\n      let bbDisjunctions =\n        bbSentenceRoot &&\n        bbSentenceRoot.children[0] &&\n        bbSentenceRoot.children[0].name === connectives.DISJUNCTION;\n\n      let nsDisjunctions =\n        newSentenceRoot &&\n        newSentenceRoot.children[0] &&\n        newSentenceRoot.children[0].name === connectives.DISJUNCTION;\n\n      let isDisjunctions = bbDisjunctions && nsDisjunctions; // both sentence have a disjunction\n\n      //SR1\n      if (bbDisjunctions || bbDisjunctions) {\n        //possible SR1\n        if (\n          nsDisjunctions &&\n          bbSentenceRoot &&\n          bbSentenceRoot.nodeType === nodeTypes.VARIABLE\n        ) {\n          //if new sentence is a disunction and n'th beliefbase sentence is a variable\n        } else if (\n          bbDisjunctions &&\n          newSentenceRoot &&\n          newSentenceRoot.nodeType === nodeTypes.VARIABLE\n        ) {\n          //if beliefbase sentence is a disunction and new sentence is a variable\n          let children = bbSentenceRoot.children[0].children.map(\n            node => node.name\n          );\n\n          var index = children.indexOf(tools.negation(newSentenceRoot.name));\n          if (index > -1) {\n            //if new sentence is a child of the bb disjunction children(SR1 is possible)\n            children.splice(index, 1); //remove compared element from children(since it already exist)\n            children.forEach(newConsequence => {\n              consequences.push([\n                newConsequence,\n                [newSentenceRoot.name, bbSentenceRoot.name]\n              ]);\n            });\n          }\n        }\n      }\n\n      //SR2\n\n      //SR4. Can confuse people\n      if (\n        bbSentenceRoot.nodeType === nodeTypes.VARIABLE &&\n        newSentenceRoot.nodeType === nodeTypes.VARIABLE\n      ) {\n        let newConsequence =\n          bbSentenceRoot.name + connectives.CONJUCTION + newSentenceRoot.name;\n        consequences.push([\n          newConsequence,\n          [newSentenceRoot.name, bbSentenceRoot.name]\n        ]);\n      }\n      //SR5\n      if (\n        isDisjunctions &&\n        bbSentenceRoot.children[0].children.length === 2 &&\n        newSentenceRoot.children[0].children.length === 2\n      ) {\n        bbSentenceRoot.children[0].children.map((bbChild, i) => {\n          //if(negation of child in other sentence children, add other child of this and other child of that intot new sentence)\n          newSentenceRoot.children[0].children.map((nsChild, k) => {\n            if (tools.negation(bbChild.name) == nsChild.name) {\n              let newConsequence =\n                bbSentenceRoot.children[0].children[i === 0 ? 1 : 0].name +\n                connectives.DISJUNCTION +\n                newSentenceRoot.children[0].children[i === 0 ? 1 : 0].name;\n              consequences.push([newConsequence, [bbChild.name, nsChild.name]]);\n\n              // TODO: change origin strings to arrays\n            }\n          });\n        });\n      }\n    });\n    this.expand(newSentence, beliefSet);\n\n    consequences.forEach(c => {\n      if (!this.inBeliefBase(c[0], beliefSet)) {\n        this.updateBeliefBase(c[0], c[1], beliefSet);\n      }\n    });\n  }\n\n  contract(sentence, beliefeSet) {\n    //First remove sentence from belifeSet\n    var index = tools.getIndexByName(sentence, beliefeSet);\n    if (index > -1) {\n      beliefeSet.splice(index, 1);\n      //map belifeSet and remove and cn of sentence\n      beliefeSet.forEach(b => {\n        let i = b.origin ? b.origin.indexOf(sentence.toString()) : -1;\n        if (i > -1) {\n          let sentenceIndex = tools.getIndexByName(b.toString(), beliefeSet); // index in database of a sentence s that is implied by sentence\n          if (sentenceIndex > -1) {\n            this.contract(b.toString(), beliefeSet);\n          }\n        }\n      });\n    }\n  }\n\n  expand(sentence, beliefeSet) {\n    beliefeSet.push(sentence);\n  }\n\n  /**\n   * Return true if result of resolution is an empty clause. Else returns false.\n   * @param Sentence sOne\n   * @param Sentence sTwo\n   */\n  resolution(sOne, sTwo) {\n    let sOneName = sOne.toString();\n    let sTwoName = sTwo.toString();\n    if (tools.negation(sOneName) === sTwoName) {\n      return true;\n    }\n    return false;\n  }\n\n  partiallyMeetContraction(sentence, belifeSet) {\n    let maxSubSets = this.maxSubsets(sentence, belifeSet);\n    belifeSet = maxSubSets[0] ? maxSubSets[0] : belifeSet;\n    return maxSubSets[0] ? maxSubSets[0] : belifeSet;\n  }\n  maxSubsets(sentence, belifeSet) {\n    let result = [];\n    belifeSet.map(belief => {\n      if (this.resolution(belief, sentence)) {\n        //empty clause\n        //(belief)\n        this.contract(belief.toString(), belifeSet);\n        belief.origin &&\n          belief.origin.forEach(o => {\n            let newSubset = [...belifeSet];\n            this.contract(o, newSubset);\n            this.expand(sentence, newSubset);\n            result.push(newSubset);\n          });\n      }\n    });\n    return result;\n  }\n  /**\n   *  Checks if sentence is consistent with beliefbase\n   *  by performing resolution on all clausees.\n   * Returns true if the new belief is consistent with the beliefset.\n   * @param {must be parsd in a Sentence object} sentence\n   * @param {*} belifeSet\n   */\n  checkConsistency(sentence, belifeSet) {\n    try {\n      for (let i = 0; i < belifeSet.length; i++) {\n        const ielement = belifeSet[i];\n        let isEemptyClause = this.resolution(sentence, ielement);\n        if (isEemptyClause) {\n          throw \"empty clause\";\n        }\n      }\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Returns true if seentencee already is in the belief base. Otherwise false.\n   * @param {*} sentence\n   * @param {*} beliefBase\n   */\n  inBeliefBase(sentence, beliefBase) {\n    let result = false;\n    let parsedSentence =\n      typeof sentence === \"string\" ? tools.parseSentence(sentence) : sentence;\n    let formatedInputSentence = \"\";\n    if (parsedSentence.syntaxTree.nodeType === nodeTypes.FORMULA) {\n      let sentenceChildren =\n        parsedSentence.syntaxTree.children.length > 0\n          ? parsedSentence.syntaxTree.children[0].children.map(c => c.name)\n          : [];\n\n      formatedInputSentence = sentenceChildren.sort().toString();\n    } else {\n      formatedInputSentence = parsedSentence.syntaxTree.name;\n    }\n\n    beliefBase.some(b => {\n      if (b.toSortedString() === formatedInputSentence) {\n        result = true;\n        return;\n      }\n    });\n\n    return result;\n  }\n\n  updateBeliefBase(stringSentence, origin, beliefBase) {\n    // parse sttring into a syntactic treee( Sentence object)\n    let parsedSentence = tools.parseSentence(stringSentence, origin);\n\n    //check if the sentence is consistent with the belief base\n    let isConsistent = this.checkConsistency(parsedSentence, beliefBase);\n\n    // if sentence is consistent add entailments\n    // and the sentence itself to the belief base\n    if (isConsistent) {\n      this.addEntailments(parsedSentence, beliefBase);\n    }\n    // else if the sentence is NOT consistent with the beliefbase,\n    // perform a partially meeet contraction\n    else {\n      beliefBase = this.partiallyMeetContraction(parsedSentence, beliefBase);\n    }\n    return beliefBase;\n  }\n}\n\n//module.exports = new RevisionHelper();\n","import React from \"react\";\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\nimport RevisionHelper from \"./Scripts/RevisionEngine\";\nclass App extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      input: \"¬QV(¬PVS)\\nQ\\nP\",\n      beliefBase: []\n    };\n  }\n\n  addBelief() {\n    let beliefBase = this.state.beliefBase;\n    let newBeliefs = this.state.input.trim().split(\"\\n\");\n    let newBelieefToAdd = newBeliefs[0];\n    if (newBelieefToAdd) {\n      let newBB = RevisionHelper.updateBeliefBase(newBelieefToAdd, null, beliefBase);\n      console.log(\"newBB\", newBB);\n      newBeliefs.splice(0, 1); //remove the added belief from texarea\n      this.setState({ input: newBeliefs.join(\"\\n\"), beliefBase: newBB });\n    }\n  }\n  render() {\n    console.log(\"this.state\", this.state);\n    return (\n      <div className=\"App\">\n        <div className=\"App-content\">\n          <div className=\"left-panel\">\n            <button onClick={this.addBelief.bind(this)}>Add belief </button>\n            <textarea\n              value={this.state.input}\n              onChange={e => this.setState({ input: e.target.value })}\n              placeholder=\"Insert beliefs in propositional logic form\"\n            />\n          </div>\n          <div className=\"right-panel\">\n            <h1>Belief base</h1>\n            {this.state.beliefBase.map(b => b + \"\\n\")}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}